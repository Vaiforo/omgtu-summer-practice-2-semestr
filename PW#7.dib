#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!csharp

using System.Collections.Concurrent;
using System.Threading;

#!csharp

public class ServerThread
{
    BlockingCollection<ICommand> serverQueue = [];
    bool needStop = false;

    public Thread Thread { get; private set; }

    public ServerThread()
    {
        Thread = new(RunServer);
        Thread.Start();
    }

    public void RunServer()
    {
        while (true)
        {
            if (needStop && serverQueue.Count == 0)
                break;

            ICommand command = serverQueue.Take();

            try
            {
                command.Execute();
            }
            catch (ThreadInterruptedException ex)
            {
                break;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                break;
            }
        }
    }

    public void AddCommand(ICommand command) => serverQueue.Add(command);

    public void StopWithEmpty() => needStop = true;
}

#!csharp

public class HardStopCommand(ServerThread serverThread) : ICommand
{
    ServerThread serverThread = serverThread;

    public void Execute()
    {
        if (serverThread.Thread != Thread.CurrentThread)
            throw new Exception(
                "HardStopError: The thread received for processing is not current!"
            );

        throw new ThreadInterruptedException();
    }
}

public class SoftStopCommand(ServerThread serverThread) : ICommand
{
    ServerThread serverThread = serverThread;

    public void Execute()
    {
        if (serverThread.Thread != Thread.CurrentThread)
            throw new Exception(
                "SoftStopError: The thread received for processing is not current!"
            );

        serverThread.StopWithEmpty();
    }
}

#!csharp

public class TestCommand : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Do something...");

        Thread.Sleep(500);

        Console.WriteLine("Ready.\n");
    }
}

#!csharp

ServerThread server1 = new();

server1.AddCommand(new TestCommand());
server1.AddCommand(new TestCommand());
server1.AddCommand(new SoftStopCommand(server1));
server1.AddCommand(new TestCommand());

server1.Thread.Join();

Console.WriteLine("Server1 stopped.\n");

ServerThread server2 = new();

server2.AddCommand(new TestCommand());
server2.AddCommand(new TestCommand());
server2.AddCommand(new HardStopCommand(server2));
server2.AddCommand(new TestCommand());

server2.Thread.Join();

Console.WriteLine("Server2 stopped.\n");
